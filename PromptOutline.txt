[INTRODUCTION]
👋 Hi, ChatGPT! I'm Silas Knight. We're building an SPA using Vue3, Composition API, Quasar, and Pinia.

[PROJECT]
🔧 WonderForge: GUI sandbox for designing and prototyping coding projects (portfolio showpiece)

[DEV ENVIRONMENT]
💻 Ubuntu 22, VSC, Chrome, Node LTS 18.15.0

[REFERENCE]
Vue3 (https://vuejs.org/guide/introduction.html)
Vue-Router (https://router.vuejs.org/guide/)
Typescript (https://www.typescriptlang.org/)
Babel (https://babeljs.io/)
Jest (https://jestjs.io/docs/getting-started)
Vue3-Jest-Typescript Testing - (https://vuejs.org/guide/scaling-up/testing.html#testing-with-jest)
Quasar CLI (https://quasar.dev/start/quasar-cli)
Pinia (https://pinia.vuejs.org/)

[MODULES]
📦 npm install --save-dev eslint eslint-plugin-prettier prettier @typescript-eslint/parser @typescript-eslint/eslint-plugin @vue/eslint-config-typescript @vue/eslint-config-prettier eslint-plugin-vue @vue/compiler-sfc vue-tsc vue-router pinia quasar sass magic-string@latest npm-check-updates interactjs

[COMMANDS]
"npm run lint -- --fix" //auto-fix prettier
"ncu" && "ncu -u" //update node modules
🚀 "quasar dev"  //launch dev mode

[STANDARDS]
🌟 Material Design, Composition API, Prettier, SCSS, Pinia Setup Stores, TypeScript standards, Kaizen, DRY Principle

[DEVELOPING FEATURES]
🌈 Gamescreen Interface, interactibles, Asset Management

[INTENDED FILE TYPES]
📁 txt, yaml, json, svg, jpg, png, gif, wmv, mp4, db, pdf, webp

[DIRECTORY]
🗂 WonderForge/
├── quasar.config.js
├── src/
│ ├── main.ts, App.vue
│ ├── assets/audio/
│ ├── assets/images/
│ ├── assets/prompts/
│ ├── boot/
│ ├── components/artgallery/
│ ├── components/assetmanager/
│ ├── components/codecards/
│ ├── components/gamescreen/
│ ├── components/screenfx/
│ ├── css/app.scss
│ ├── css/quasar.variables.scss
│ ├── layout/
│ ├── views/
│ ├── router/index.ts
│ └── stores/projects.ts
│ └── stores/types.ts
└── public/images/

[PROGRESS]
Installed modules, basic routing and page structures, created HomePage layout,  ButterflyMascot interactible, remodeled router to use lazy loading, Setup HomePage with stylized butterfly wings, app.scss as global scss, quasar.variables.scss for css variables, rebuilt files from project up: types, projects, componentgenerator, router.

[TODO]
setup API layer, possibly RESTful API


[CONFIG FILES]
index.html, quasar.config.js, app.scss, tsconfig.json, postcss.config.js, .eslintrc.js, .prettierrc, package.json, main.ts, app.vue

[BASE FILES RECREATED]
stores/types.ts
stores/projects.ts
routes/index.ts
HomePage //Home
ErrorScreen //404
UnderConstruction //Under Construction
ButterflyMascot //website mascot interactible
TitleBar //stylized title

[CURRENTLY WORKING ON]
LayoutEditor.vue //scss manager
NavigationMenu //isActive components
AccordionGallery //website configuration
ChatInterface // Chatroom Interface
VoiceControl //basic voice pickup and text output
UserLogin //User Login
SettingsPanel //User Settings
RandomText  //RandomText(parameters)
RandomImage // RandomImage(parameters)
TextInput // Text Input Window
AssetManager  // Asset manager
CodeCard // Base class for customizable cards
RainDrops //background screen effect
LavaLamp //background screen effect
SoapBubbles //background screen effect
SplashImage //background screen effect
MagicFrame //resizeable and draggable stylized window frame
MagicRemote //modular interface controller
GameScreen //modular screen display interface with step-based save system
ArtGallery //customizable Art Asset gallery viewer

[NOTE]
I want to avoid outside modules unless they provide a specific desired utility. We are attempting to develop bare metal javascript vue typed code solutions with minimal dependences outside our own codebase. I am always interested in learning about related paradigms that might provide assistance with organizing our data and recovering them programmatically, and understanding the essence and intent of code interactions to follow wise practices. Best practices are good, but wise practices are best. Code should be easy to edit, easy to read, and easy to follow.

[EXTENDED NOTES]
Limit required variables, give sensible defaults whenever appropriate.
Choose the wisest sensible unique id (name or path), and add reasonable options. Beginning and end points should be clear and natural language, we are building front-end and back-end systems simultaneously.

[SELECTION MENU]
1. Brainstorm session
2. High Level System Overview
3. Focused Project Outline
4. Step-based instructions
5. Code Review
6. Style Review
7. Critical Analysis of Project
8. Next Steps Project Outline
9. Toggle Text Adventure Quest Mode (status: off)
0. Custom

Selection:
3, I'm working with images. I want the equivalent to Bare metal access to image files at path level, and the ability to recover random images from photosets, modellers, tags, or galleries.

[TYPES]
Image: a single image file, currently using webp exclusively for testing. Every image is in one photoset, may have one Modeller, and may be in zero, 1 or many Galleries. Each image was created with a Modeller. A Modeller makes many images. An image currently only has one modeler, We are not currently working with the modelers, we are just tracking with modeller was used to make each image for display and information

Gallery: a collection of images. instructed by a json in @/assets/galleries/{ gallery.name }. Many:Many relationship

Photoset: a collection of images currently identified by folder grouping. Every image has a photoset. Default "unsorted". A photoset is made by a modeller. One photoset: many images

Modeller: an NLP model checkpoint used to generate the images. It will be very important to sort by later when we setup galleries, so we want it worked in now. A Modeller has a unique hash id and unique natural language reference name. Modellers make photosets

Tag: string identification system used to simplify categorization

[DATABASE]
This is a note for later. We have a hosted mariadb database with modeler data. I assume it is good to establish this structure on this side before we integrate, as I want this to be more agnostic. I would love advise on how to connect the two efficiently. I control both sides from the same set of servers, but they are independent machines.

[Intent]
I functionally want GalleryManager.vue that I can query for gallery name, photoset, modeler, tag. or image id and get back the image , set, object, or a randomized subset in simple, easy language, and GalleryViewer.vue that will display a selected subset of photos using our AccordionGallery for display.

I rebuilt types.ts.
Please advise:
// Tags are our high-level concept organization
export interface Tag {
  name: string;
  Tags?: Tag[];
}
//filepath can be remote or local
export interface filePath {
  filePath: string;
  Tags?: Tag[];
}
//image is identified by filepath
export interface Image {
  filepath: filePath;
  PrimaryTag?: Tag;
  SecondaryTags?: Tag[];
  photoset?: Photoset;
  modeler?: Modeler;
  height?: number;
  width?: number;
  steps?: number;
  cfg?: number;
  sampler?: string;
  seed?: number;
}

// Modeler interface
export interface Modeler {
  name: Tag;
  hash?: string;
  tags?: Tag[];
  filepath?: filePath;
  infoUrl?: filePath;
}

//Photosets are themed collections of images sorted by folder
export interface Photoset {
  name: string;
  path: filePath;
  tags?: Tag[];
}

//Gallery is a sorted collection of images
export interface Gallery {
  name: string;
  tags?: Tag[];
  path?: filePath;
  images?: Image[];
  photosets?: Photoset[];
  modelers?: Modeler[];
}
