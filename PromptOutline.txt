[INTRODUCTION]
👋 Hi, ChatGPT! I'm Silas Knight. We're building an SPA using Vue3, Composition API, Quasar, and Pinia.

[PROJECT]
🔧 WonderForge: GUI sandbox for designing and prototyping coding projects (portfolio showpiece)

[DEV ENVIRONMENT]
💻 Ubuntu 22, VSC, Chrome, Node LTS 18.15.0

[REFERENCE]
Vue3 (https://vuejs.org/guide/introduction.html)
Vue-Router (https://router.vuejs.org/guide/)
Typescript (https://www.typescriptlang.org/)
Babel (https://babeljs.io/)
Jest (https://jestjs.io/docs/getting-started)
Vue3-Jest-Typescript Testing - (https://vuejs.org/guide/scaling-up/testing.html#testing-with-jest)
Quasar CLI (https://quasar.dev/start/quasar-cli)
Pinia (https://pinia.vuejs.org/)

[MODULES]
📦 npm install --save-dev eslint eslint-plugin-prettier prettier @typescript-eslint/parser @typescript-eslint/eslint-plugin @vue/eslint-config-typescript @vue/eslint-config-prettier eslint-plugin-vue @vue/compiler-sfc vue-tsc vue-router pinia quasar sass magic-string@latest npm-check-updates interactjs

[COMMANDS]
"npm run lint -- --fix" //auto-fix prettier
"ncu" && "ncu -u" //update node modules
🚀 "quasar dev"  //launch dev mode

[STANDARDS]
🌟 Material Design, Composition API, Prettier, SCSS, Pinia Setup Stores, TypeScript standards, Kaizen, DRY Principle

[DEVELOPING FEATURES]
🌈 Gamescreen Interface, interactibles, Asset Management

[INTENDED FILE TYPES]
📁 txt, yaml, json, svg, jpg, png, gif, wmv, mp4, db, pdf, webp

[DIRECTORY]
🗂 WonderForge/
├── quasar.config.js
├── src/
│ ├── main.ts, App.vue
│ ├── assets/audio/
│ ├── assets/images/
│ ├── assets/prompts/
│ ├── boot/
│ ├── components/artgallery/
│ ├── components/assetmanager/
│ ├── components/codecards/
│ ├── components/gamescreen/
│ ├── components/screenfx/
│ ├── css/app.scss
│ ├── css/quasar.variables.scss
│ ├── layout/
│ ├── views/
│ ├── router/index.ts
│ └── stores/projects.ts
│ └── stores/types.ts
└── public/images/

[PROGRESS]
Installed modules, basic routing and page structures, created HomePage layout, beginning voice integration with SpeechKitt, accordion gallery, moved style and design sections to "WonderForge Styleguide", ButterflyMascot interactible, draggable-resizable magicscreen, remodeled router to use lazy loading, Setup HomePage with stylized butterfly wings, app.scss as global scss, with quasar.variables.scss for css variables.

[CONFIG FILES]
index.html, quasar.config.js, app.scss, tsconfig.json, postcss.config.js, .eslintrc.js, .prettierrc, package.json, main.ts, app.vue

[BASE FILES RECREATED]
stores/types.ts
stores/projects.ts
routes/index.ts
HomePage //Home
ErrorScreen //404
ButterflyMascot //website mascot interactible

[CURRENTLY WORKING ON]
LayoutEditor.vue //scss manager


[LEFT TO STITCH IN]
UnderConstruction //Under Construction
TitleBar //stylized title
NavigationMenu //isActive components
AccordionGallery //website configuration
ChatInterface // Chatroom Interface
VoiceControl //basic voice pickup and text output
UserLogin //User Login
SettingsPanel //User Settings
RandomText  //RandomText(parameters)
RandomImage // RandomImage(parameters)
TextInput // Text Input Window

[./components/assetmanager/]
AssetManager  // Asset manager

[./components/codecards/]
CodeCard // Base class for customizable cards


[./components/screenfx/]
RainDrops //background screen effect
LavaLamp //background screen effect
SoapBubbles //background screen effect
SplashImage //background screen effect
MagicFrame //resizeable and draggable stylized window frame
MagicRemote //modular interface controller

[./components/gamescreen/]
GameScreen //modular screen display interface with step-based save system

[./components/artgallery/]
ArtGallery //customizable Art Asset gallery viewer

[NOTE]
I want to avoid outside modules unless they provide a specific desired utility. We are attempting to develop bare metal javascript vue typed code solutions with minimal dependences outside our own codebase. I am always interested in learning about related paradigms that might provide assistance with organizing our data and recovering them programmatically.

[Personality Select]
1. Brainstorm session
2. High Level System Overview
3. Focused Project Outline
4. Step-based instructions
5. Code Review
6. Style Review
7. Critical Analysis of Project
8. Next Steps Project Outline
9. Toggle Text Adventure Quest Mode (status: off)
0. Custom

Selection: 0:
Help me separate out concerns from the router/index.ts. I want to create a separate ActiveComponents.ts that reads my projects.ts file and exports the helpful bits for index.
// src/router/index.ts
import {
  createRouter,
  createWebHistory,
  Router,
  RouteRecordRaw,
} from 'vue-router';
import { Project } from '@/stores/types';
import { projects } from '@/stores/projects';

import ErrorScreen from '@/components/layout/ErrorScreen.vue';
import HomePage from '@/components/layout/HomePage.vue';

function getActiveProjects(projects: Project[]): Project[] {
  return projects.filter((project) => project.isActive);
}

function createRoute(project: Project, componentName: string): RouteRecordRaw {
  return {
    path: `/${project.name.toLowerCase()}/${componentName.toLowerCase()}`,
    name: `${project.name}-${componentName}`,
    meta: {
      isActive: project.isActive,
    },
    component: () =>
      import(
        /* @vite-ignore */
        `@/components/${project.name.toLowerCase()}/${componentName}.vue`
      ).catch(() => {
        console.error(
          `Error loading component for project: ${project.name}, component: ${componentName}`
        );
        return Promise.reject(new Error('Failed to load component'));
      }),
  };
}

function createRoutes(activeProjects: Project[]): RouteRecordRaw[] {
  const routes: RouteRecordRaw[] = [];

  activeProjects.forEach((project) => {
    project.components.forEach((componentName) => {
      const route = createRoute(project, componentName);
      routes.push(route);
    });
  });

  return routes;
}

function addRoutesToRouter(router: Router, routes: RouteRecordRaw[]) {
  routes.forEach((route: RouteRecordRaw) => {
    router.addRoute(route);
  });
}

function addActiveProjectsToRouter(projects: Project[], router: Router) {
  const activeProjects = getActiveProjects(projects);
  const routes: RouteRecordRaw[] = createRoutes(activeProjects);
  addRoutesToRouter(router, routes);
}

// Add the HomePage route and the ErrorScreen route as the last route in the array
const routes: RouteRecordRaw[] = [
  {
    path: '/', // <-- Add this route for the HomePage
    name: 'HomePage',
    component: HomePage,
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'ErrorScreen',
    component: ErrorScreen,
  },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// Call the addActiveProjectsToRouter function
addActiveProjectsToRouter(projects, router);

export default router;
export { routes };



