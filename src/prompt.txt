[INTRODUCTION]
ğŸ‘‹ Hi, ChatGPT! I'm Silas Knight. I'm building an SPA using Vue3, Composition API, Quasar, and Pinia.

[PROJECT]
ğŸ”§ WonderForge: A GUI sandbox for rapidly prototyping development and coding projects
(with a pleasing interface and best practices to serve as a portfolio showpiece)

[DEV ENVIRONMENT]
ğŸ’» Ubuntu 22, VSC, Chrome, Node LTS 18.15.0

[RUN COMMAND]
ğŸš€ "quasar dev"

[MODULES]
ğŸ“¦ @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint eslint-config-prettier eslint-plugin-prettier prettier
quasar pinia vue-tsc @vue/compiler-sfc, Vue3, fontawesome-v6, SASS, Vue-Router, vuedraggable, vue-resizable

[STANDARDS]
ğŸŒŸ Material Design, Composition API, Prettier, SCSS, Pinia Setup Stores
Use <script lang="ts">
Use <style scoped lang="scss">
Use Quasar components when available
Use Pinia useAppStore.ts store for state management
Components must have TwoWord names
Adhere to current TypeScript standards
Separate concerns. Avoid hardcoding data in application logic

[VARIABLES]
ğŸ¨ colors: $primary, $secondary, $accent, $dark, $warning, $dark-page, $positive, $negative, $info

[DEVELOPING FEATURES]
ğŸŒˆ Step-Based Save System
User Logins
Night Mode
Playspace Paint mode
Labspace API Card GUI
Screenspace Screen/Card Management
Chat
ScreenSpace Remote Control
OpenAI Secure Key Storage
Future: PlaySpace Toys (Superball Cannon, Graffiti Secret 2D Adventure Mode, Bouncing Balls, Destructible Screen Effects)

[INTENDED FILE TYPES]
ğŸ“ txt, yaml, json, svg, jpg, png, gif, wmv, mp4, db, pdf, webp

[DIRECTORY]
ğŸ—‚ WonderForge/
â”œâ”€â”€ quasar.config.js
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.ts
â”‚ â”œâ”€â”€ App.vue
â”‚ â”œâ”€â”€ assets/
â”‚ â”œâ”€â”€ boot/
â”‚ â”œâ”€â”€ components/
â”‚ â”œâ”€â”€ css/
â”‚ â”œâ”€â”€ layouts/
â”‚ â”œâ”€â”€ pages/
â”‚ â”œâ”€â”€ router/
â”‚ â””â”€â”€ stores/
â””â”€â”€ public/
â””â”€â”€ images/

[PRIMARY FOLDERS]
ğŸ“‚ ./router/index.ts
[/stores/] useAppStore.ts, useAuthStore.ts, types.ts
[/css/] css.quasar.variables
[layouts/] AppLayout.vue, AppCenter.vue
[pages/] ErrorNotFound, LoginForm, MainWindow, RemoteControl, SplashPage, TitleBar, UnderConstruction
ROOT: quasar.config.js, tsconfig.json, .eslintrc.js, .prettierrc, index.html, package.json, postcss.config.js
[src/] Main, App.vue

[useAppStore]
state
- user
- isLoggedIn
- nightMode
- screenCards
- nextCardId
- selectedCardIds
- stepHistory
- componentVisibility
- gridWidth
- gridHeight
- gridCellSize
getters
- getScreenCardById(id: number): ScreenCard | undefined
actions
- login(email: string, password: string): boolean
- logout(): void
- toggleNightMode(): void
addScreenCard(card: Omit<ScreenCard, 'id'>): void
- updateScreenCard(card: ScreenCard): void
- removeScreenCard(id: number): void
- selectCard(id: number): void
- deselectCard(id: number): void
- removeSelectedCards(): void
- saveStep(): void
- undo(): void
- toggleComponentVisibility(componentName: string): void
- setGridWidth(width: number): void
- setGridHeight(height: number): void
- setGridCellSize(size: number): void

[PROGRESS]
Installed Quasar CLI, Vue3, SASS and other listed modules
Setup variable references and SCSS styling
Configured useAppStore and useAuthStore with demo options
Established types.ts
Designed routing and Page structures
main.ts loads App.vue and shows splash image (woohoo)
AppLayout displays AppHeader, AppFooter, MainWindow, and AppSidebar (Working on this)

[LAYOUTS]
ğŸ¨ AppLayout is the main application layout that includes AppHeader, AppFooter, AppCenter, and AppSidebar components. It uses the Quasar framework to set up the layout structure and relies on the useAppStore for managing the state of component visibility. AppCenter.vue component is responsible for handling the central screen display and maintaining the separation between screens.

[SUGGESTED REPLY FORMAT]
a. fun emoticon and fun and inspiring phrase
1. Comment on code and project thus far
2. Improved Code that will work within our structure
3. The file or files you'd like to see next
4. Any Additional comments


[status]
sharing files for further development, refining these design specs together, and iterating on this process.
Return this outline updated with Layout summary and other elaborations in efficient markup
